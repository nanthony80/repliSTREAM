---
title: "microdecon_edna_container_app"
author: "Nicole Anthony"
date: "`r Sys.Date()`"
output: html_document
---

# Introduction
This analysis applies the microDecon algorithm to LULU-curated OTU tables generated from eDNA metabarcoding data processed with the eDNA Container App, using publicly available datasets from Ballini et al. (2024). The curated OTU tables were produced from amplicon sequence variant (ASV) data, following reference database creation with CRABS (Creating Reference Databases for Amplicon-Based Sequencing) as per Ballini et al. (2024) with some modifications. The database was converted to a QIIME2-compatible format for use in the eDNA Container App, which generated the ASV tables used as input to LULU. See the repliSTREAM README.md for details on database creation, QIIME2 conversion, and LULU processing.

## microDecon Following LULU
microDecon (v1.0.2, https://github.com/donaldtmcknight/microDecon) is used to identify and remove potential contamination from high-throughput sequencing datasets. It requires both experimental samples and negative control (blank) samples to estimate and subtract contamination levels.

The algorithm works by:

- Calculating the proportion of each taxon found in negative control samples.
- Adjusting the read counts in experimental samples by removing these estimated contaminant contributions.

This step improves data quality by reducing false-positive detections and ensuring that downstream biodiversity metrics more accurately reflect true biological signals.

### Set-up for microDecon
Copy the following curated OTU tables from the LULU analysis into a new directory called microdecon/:

- `tele02_curated_otu_table_aggregated_microdecon.csv`

- `vert01_curated_otu_table_aggregated_microdecon.csv`

These files include both experimental and negative control samples and serve as direct input for the microDecon workflow.

## References

Ballini, L., Staffoni, G., Nespoli, D., et al. (2025). Environmental DNA metabarcoding as an efficient tool to monitor freshwater systems in northwestern Italy. Hydrobiologia, 852, 791–803. https://doi.org/10.1007/s10750-024-05723-y

Frøslev, T. G., Kjøller, R., Bruun, H. H., et al. (2017). Algorithm for post-clustering curation of DNA amplicon data yields reliable biodiversity estimates. Nature Communications, 8, 1188. https://doi.org/10.1038/s41467-017-01312-x

Jeunen, G. J., Dowle, E., Edgecombe, J., von Ammon, U., Gemmell, N. J., & Cross, H. (2023). crabs: A software program to generate curated reference databases for metabarcoding sequencing data. Molecular Ecology Resources, 23(3), 725–738. https://doi.org/10.1111/1755-0998.13741

McKnight, D. T., Huerlimann, R., Bower, D. S., Schwarzkopf, L., Alford, R. A., & Zenger, K. R. (2019). microDecon: A highly accurate read-subtraction tool for the post-sequencing removal of contamination in metabarcoding studies. Environmental DNA. https://doi.org/10.1002/edn3.11

Wheeler, D., Brancalion, L., Kawasaki, A., & Rourke, M. L. (2024). The eDNA-Container App: A simple-to-use cross-platform package for the reproducible analysis of eDNA sequencing data. Applied Sciences, 14(6), 2641. https://doi.org/10.3390/app14062641


# Install package and load libraries
```{r}
# library(devtools)
# devtools::install_github("donaldtmcknight/microDecon")
library(microDecon)
library(tibble)
library(tidyverse)
library(dplyr)
```

# Prepare OTU tables for microDecon format
We converted our manually curated tables from LULU into the format requested by microDecon (1-3 below). Default options were applied.

A properly formatted OTU table for microDecon should have:
1. First column (OTU_ID) → Unique OTU identifiers.
2. Next columns (Blank samples) → Negative controls (samples with expected contamination).
3. Following columns (Real samples) → Actual biological/metabarcoding samples.
4. Final column (Taxa, optional) → Taxonomic assignment (e.g., Kingdom, Phylum, etc.).

## Load OTU tables from LULU
```{r}
# load OTU tables 
tele02_microdecon <- read.csv("tele02_curated_otu_table_aggregated_microdecon.csv", header = TRUE, check.names = FALSE)
vert01_microdecon <- read.csv("vert01_curated_otu_table_aggregated_microdecon.csv", header = TRUE, check.names = FALSE)

# rename the first column to "OTU_ID" and coerce all sample columns to numeric
tele02_microdecon <- tele02_microdecon %>%
  rename(OTU_ID = 1) %>%
  mutate(across(-OTU_ID, as.numeric))

vert01_microdecon <- vert01_microdecon %>%
  rename(OTU_ID = 1) %>%
  mutate(across(-OTU_ID, as.numeric))

# check for duplicated OTU IDs
sum(duplicated(tele02_microdecon$OTU_ID))
sum(duplicated(vert01_microdecon$OTU_ID))

# check structure
str(tele02_microdecon)
head(tele02_microdecon)
colnames(tele02_microdecon)
str(vert01_microdecon)
head(vert01_microdecon)
colnames(vert01_microdecon)
```


# Run microDecon for Tele02 River Subsets

```{r}
# define sample information for all tele02 rivers
tele02_river_samples <- list(
  ARGENTINA = list(
    blank = c("SRR31057121ARGENTINAnegTele02", "SRR31057075NAPCRnegTele02"),
    real  = c("SRR31057115ARGENTINAr1Tele02",
              "SRR31057116ARGENTINAr2Tele02",
              "SRR31057117ARGENTINAr3Tele02",
              "SRR31057118ARGENTINAr4Tele02",
              "SRR31057119ARGENTINAr5Tele02",
              "SRR31057120ARGENTINAr6Tele02")
  ),
  BEVERA = list(
    blank = c("SRR31057090BEVERAnegTele02", "SRR31057075NAPCRnegTele02"),
    real  = c("SRR31057084BEVERAr1Tele02",
              "SRR31057085BEVERAr2Tele02",
              "SRR31057086BEVERAr3Tele02",
              "SRR31057087BEVERAr4Tele02",
              "SRR31057088BEVERAr5Tele02",
              "SRR31057089BEVERAr6Tele02")
  ),
  CARPASINA = list(
    blank = c("SRR31057098CARPASINAnegTele02", "SRR31057075NAPCRnegTele02"),
    real  = c("SRR31057091CARPASINAr1Tele02",
              "SRR31057093CARPASINAr2Tele02",
              "SRR31057094CARPASINAr3Tele02",
              "SRR31057095CARPASINAr4Tele02",
              "SRR31057096CARPASINAr5Tele02",
              "SRR31057097CARPASINAr6Tele02")
  ),
  NERVIA = list(
    blank = c("SRR31057083NERVIAnegTele02", "SRR31057075NAPCRnegTele02"),
    real  = c("SRR31057076NERVIAr1Tele02",
              "SRR31057077NERVIAr2Tele02",
              "SRR31057078NERVIAr3Tele02",
              "SRR31057079NERVIAr4Tele02",
              "SRR31057080NERVIAr5Tele02",
              "SRR31057082NERVIAr6Tele02")
  ),
  ROIA = list(
    blank = c("SRR31057113ROIAnegTele02", "SRR31057075NAPCRnegTele02"),
    real  = c("SRR31057107ROIAr1Tele02",
              "SRR31057108ROIAr2Tele02",
              "SRR31057109ROIAr3Tele02",
              "SRR31057110ROIAr4Tele02",
              "SRR31057111ROIAr5Tele02",
              "SRR31057112ROIAr6Tele02")
  ),
  TANARO = list(
    blank = c("SRR31057106TANAROnegTele02", "SRR31057075NAPCRnegTele02"),
    real  = c("SRR31057099TANAROr1Tele02",
              "SRR31057100TANAROr2Tele02",
              "SRR31057101TANAROr3Tele02",
              "SRR31057102TANAROr4Tele02",
              "SRR31057104TANAROr5Tele02",
              "SRR31057105TANAROr6Tele02")
  )
)

# function to check data quality and run microDecon
process_river_microdecon <- function(data, river_name, blank_samples, real_samples, verbose = TRUE) {
  
  if (verbose) cat("\n=== Processing", river_name, "===\n")
  
  # subset data
  river_data <- data %>%
    select(OTU_ID, all_of(blank_samples), all_of(real_samples))
  
  if (verbose) {
    cat("Data dimensions:", nrow(river_data), "x", ncol(river_data), "\n")
    
    # quality checks
    num_check <- sapply(river_data[,-1], is.numeric)
    cat("All numeric:", all(num_check), "\n")
    cat("NA values:", sum(is.na(river_data)), "\n")
    
    # check for zero columns
    zero_cols <- colSums(river_data[,-1]) == 0
    cat("Columns with all zeros:", sum(zero_cols), "\n")
    if (sum(zero_cols) > 0) {
      cat("Zero columns:", names(zero_cols[zero_cols]), "\n")
    }
  }
  
  # check if blank sample is all zeros
  blank_is_zero <- all(river_data[[blank_samples[1]]] == 0)
  
  if (blank_is_zero) {
    if (verbose) cat("WARNING: Blank sample is all zeros. Skipping microDecon and returning real samples only.\n")
    
    # return only real samples (no decontamination possible)
    result <- list(
      decon.table = river_data %>% select(OTU_ID, all_of(real_samples))
    )
  } else {
    if (verbose) cat("Running microDecon...\n")
    
    # run microDecon
    result <- decon(
      data = river_data,
      numb.blanks = 2,
      numb.ind = length(real_samples),
      taxa = FALSE
    )
  }
  
  if (verbose) {
    cat("Output dimensions:", nrow(result$decon.table), "x", ncol(result$decon.table), "\n")
  }
  
  return(result)
}

# process all rivers
tele02_cleaned_results <- list()

for (river in names(tele02_river_samples)) {
  tele02_cleaned_results[[river]] <- process_river_microdecon(
    data = tele02_microdecon,
    river_name = river,
    blank_samples = tele02_river_samples[[river]]$blank,
    real_samples = tele02_river_samples[[river]]$real,
    verbose = TRUE
  )
}

# access individual results
tele02_argentina_cleaned <- tele02_cleaned_results$ARGENTINA
tele02_bevera_cleaned <- tele02_cleaned_results$BEVERA
tele02_carpasina_cleaned <- tele02_cleaned_results$CARPASINA
tele02_nervia_cleaned <- tele02_cleaned_results$NERVIA
tele02_roia_cleaned <- tele02_cleaned_results$ROIA
tele02_tanaro_cleaned <- tele02_cleaned_results$TANARO

# summary of all results
cat("\n=== TELE02 SUMMARY ===\n")
for (river in names(tele02_cleaned_results)) {
  result <- tele02_cleaned_results[[river]]
  cat(sprintf("%s: %d OTUs x %d samples\n", 
              river, 
              nrow(result$decon.table), 
              ncol(result$decon.table) - 1))  # -1 for OTU_ID column
}
```


# Run microDecon for Vert01 River Subsets

```{r}
# define sample information for all vert01 rivers
vert01_river_samples <- list(
  ARGENTINA = list(
    blank = c("SRR31057159ARGENTINAnegVert01", "SRR31057123NAPCRnegVert01"),
    real  = c("SRR31057103ARGENTINAr1Vert01",
              "SRR31057114ARGENTINAr2Vert01",
              "SRR31057125ARGENTINAr3Vert01",
              "SRR31057136ARGENTINAr4Vert01",
              "SRR31057147ARGENTINAr5Vert01",
              "SRR31057158ARGENTINAr6Vert01")
  ),
  BEVERA = list(
    blank = c("SRR31057139BEVERAnegVert01", "SRR31057123NAPCRnegVert01"),
    real  = c("SRR31057132BEVERAr1Vert01",
              "SRR31057133BEVERAr2Vert01",
              "SRR31057134BEVERAr3Vert01",
              "SRR31057135BEVERAr4Vert01",
              "SRR31057137BEVERAr5Vert01",
              "SRR31057138BEVERAr6Vert01")
  ),
  CARPASINA = list(
    blank = c("SRR31057146CARPASINAnegVert01", "SRR31057123NAPCRnegVert01"),
    real  = c("SRR31057140CARPASINAr1Vert01",
              "SRR31057141CARPASINAr2Vert01",
              "SRR31057142CARPASINAr3Vert01",
              "SRR31057143CARPASINAr4Vert01",
              "SRR31057144CARPASINAr5Vert01",
              "SRR31057145CARPASINAr6Vert01")
  ),
  NERVIA = list(
    blank = c("SRR31057131NERVIAnegVert01", "SRR31057123NAPCRnegVert01"),
    real  = c("SRR31057124NERVIAr1Vert01",
              "SRR31057126NERVIAr2Vert01",
              "SRR31057127NERVIAr3Vert01",
              "SRR31057128NERVIAr4Vert01",
              "SRR31057129NERVIAr5Vert01",
              "SRR31057130NERVIAr6Vert01")
  ),
  ROIA = list(
    blank = c("SRR31057092ROIAnegVert01", "SRR31057123NAPCRnegVert01"),
    real  = c("SRR31057155ROIAr1Vert01",
              "SRR31057156ROIAr2Vert01",
              "SRR31057157ROIAr3Vert01",
              "SRR31057072ROIAr4Vert01",
              "SRR31057073ROIAr5Vert01",
              "SRR31057081ROIAr6Vert01")
  ),
  TANARO = list(
    blank = c("SRR31057154TANAROnegVert01", "SRR31057123NAPCRnegVert01"),
    real  = c("SRR31057148TANAROr1Vert01",
              "SRR31057149TANAROr2Vert01",
              "SRR31057150TANAROr3Vert01",
              "SRR31057151TANAROr4Vert01",
              "SRR31057152TANAROr5Vert01",
              "SRR31057153TANAROr6Vert01")
  )
)

# function to check data quality and run microDecon
process_river_microdecon <- function(data, river_name, blank_samples, real_samples, verbose = TRUE) {
  
  if (verbose) cat("\n=== Processing", river_name, "- Vert01 ===\n")
  
  # subset data
  river_data <- data %>%
    select(OTU_ID, all_of(blank_samples), all_of(real_samples))
  
  if (verbose) {
    cat("Data dimensions:", nrow(river_data), "x", ncol(river_data), "\n")
    
    # quality checks
    num_check <- sapply(river_data[,-1], is.numeric)
    cat("All numeric:", all(num_check), "\n")
    cat("NA values:", sum(is.na(river_data)), "\n")
    
    # check for zero columns
    zero_cols <- colSums(river_data[,-1]) == 0
    cat("Columns with all zeros:", sum(zero_cols), "\n")
    if (sum(zero_cols) > 0) {
      cat("Zero columns:", names(zero_cols[zero_cols]), "\n")
    }
  }
  
  # check if blank sample is all zeros
  blank_is_zero <- all(river_data[[blank_samples[1]]] == 0)
  
  if (blank_is_zero) {
    if (verbose) cat("WARNING: Blank sample is all zeros. Skipping microDecon and returning real samples only.\n")
    
    # Return only real samples (no decontamination possible)
    result <- list(
      decon.table = river_data %>% select(OTU_ID, all_of(real_samples))
    )
  } else {
    if (verbose) cat("Running microDecon...\n")
    
    # run microDecon
    result <- decon(
      data = river_data,
      numb.blanks = 2,
      numb.ind = length(real_samples),
      taxa = FALSE
    )
  }
  
  if (verbose) {
    cat("Output dimensions:", nrow(result$decon.table), "x", ncol(result$decon.table), "\n")
  }
  
  return(result)
}

# process all vert01 rivers
vert01_cleaned_results <- list()

for (river in names(vert01_river_samples)) {
  vert01_cleaned_results[[river]] <- process_river_microdecon(
    data = vert01_microdecon,
    river_name = river,
    blank_samples = vert01_river_samples[[river]]$blank,
    real_samples = vert01_river_samples[[river]]$real,
    verbose = TRUE
  )
}

# access individual results
vert01_argentina_cleaned <- vert01_cleaned_results$ARGENTINA
vert01_bevera_cleaned <- vert01_cleaned_results$BEVERA
vert01_carpasina_cleaned <- vert01_cleaned_results$CARPASINA
vert01_nervia_cleaned <- vert01_cleaned_results$NERVIA
vert01_roia_cleaned <- vert01_cleaned_results$ROIA
vert01_tanaro_cleaned <- vert01_cleaned_results$TANARO

# summary of all vert01 results
cat("\n=== VERT01 SUMMARY ===\n")
for (river in names(vert01_cleaned_results)) {
  result <- vert01_cleaned_results[[river]]
  cat(sprintf("%s: %d OTUs x %d samples\n", 
              river, 
              nrow(result$decon.table), 
              ncol(result$decon.table) - 1))  # -1 for OTU_ID column
}
```




# Final Taxon Lists by River (individual samples) and Marker
```{r}
# function to save cleaned results for a marker
save_marker_results <- function(results_list, marker_name) {
  for (river in names(results_list)) {
    filename <- paste0(tolower(marker_name), "_", tolower(river), "_cleaned.csv")
    write.csv(results_list[[river]]$decon.table, filename, row.names = FALSE)
    cat("Saved:", filename, "\n")
  }
}

# save all results
save_marker_results(tele02_cleaned_results, "Tele02")
save_marker_results(vert01_cleaned_results, "Vert01")
```



# Final Taxon Lists by Marker
```{r}
# function to process marker results into summed output
process_marker_output <- function(results_list, marker_name) {
  
  cat("Processing", marker_name, "results...\n")
  
  # process all rivers at once using map and reduce
  river_data <- map(names(results_list), function(river) {
    df <- results_list[[river]]$decon.table
    
    # sum reads across all sample columns (excluding OTU_ID)
    df_summed <- df %>%
      mutate(!!tolower(river) := rowSums(select(., -OTU_ID))) %>%
      select(OTU_ID, !!tolower(river))
    
    return(df_summed)
  })
  
  # combine all rivers with full joins
  output <- reduce(river_data, full_join, by = "OTU_ID")
  
  cat("Completed", marker_name, "with", nrow(output), "OTUs across", 
      ncol(output)-1, "rivers\n")
  
  return(output)
}

# process both markers
tele02_microdecon_output <- process_marker_output(tele02_cleaned_results, "Tele02")
vert01_microdecon_output <- process_marker_output(vert01_cleaned_results, "Vert01")

# check results
head(tele02_microdecon_output)
head(vert01_microdecon_output)

# save files
write.csv(tele02_microdecon_output, "tele02_microdecon_output.csv", row.names = FALSE)
write.csv(vert01_microdecon_output, "vert01_microdecon_output.csv", row.names = FALSE)

cat("Files saved successfully!\n")
```




