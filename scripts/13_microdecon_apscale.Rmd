---
title: "microdecon_apscale"
author: "Nicole Anthony"
date: "`r Sys.Date()`"
output: html_document
---

This analysis uses publicly available data from Ballini et al. (2024).Sample sequences were initially processed using APSCALE v4.1.3 (Buchner et al. 2022), an eDNA metabarcoding pipeline that denoises raw sequencing data and generates Amplicon Sequence Variants (ASVs) or Operational Taxonomic Units (OTUs). APSCALE directly incorporates the LULU algorithm for post-clustering curation, reducing spurious OTUs and improving biodiversity metrics.

Taxonomic assignment was performed using APSCALE-BLAST, which matches denoised sequence variants against curated reference databases. To facilitate downstream analyses, TaxonTableTools2 (TTT2) (Macher et al. 2021) was used to merge the APSCALE read and taxonomy tables, producing species datasets as input to microDecon for decontamination.

## Set-up for microDecon

To run microDecon, copy the merged taxon tables generated by TTT2 into a new directory called `microdecon/` and rename them as follows:

- `tele02_taxon_table_microdecon.csv`
- `vert01_taxon_table_microdecon.csv`

These files should include both experimental and negative control samples and will serve as input for the microDecon workflow.

## microDecon following APSCALE

microDecon (v1.0.2, https://github.com/donaldtmcknight/microDecon) is a method for identifying and removing contaminant reads post-sequencing. It uses one or more blank (negative control) samples that were carried throughout the project (collection, extraction, amplification, and sequencing) to estimate contamination. 

microDecon works by:

- Calculating the proportion of each taxon found in negative control samples.
- Adjusting the read counts in experimental samples by subtracting these estimated contaminant contributions.

Because microDecon removes reads rather than entire OTUs, it is a significant improvement over existing methods, resulting in more accurate biodiversity estimates.

## References

Ballini, L., Staffoni, G., Nespoli, D. et al. (2025). Environmental DNA metabarcoding as an efficient tool to monitor freshwater systems in northwestern Italy. Hydrobiologia, 852, 791–803. https://doi.org/10.1007/s10750-024-05723-y

Buchner, D., Macher, T. H., & Leese, F. (2022). APSCALE: advanced pipeline for simple yet comprehensive analyses of DNA metabarcoding data. Bioinformatics 38(20), 4817–4819. https://doi.org/10.1093/bioinformatics/btac588

Frøslev, T.G., Kjøller, R., Bruun, H.H. et al. (2017). Algorithm for post-clustering curation of DNA amplicon data yields reliable biodiversity estimates. Nat Commun, 8, 1188. https://doi.org/10.1038/s41467-017-01312-x

Macher, T.H., Beermann, A. J., & Leese, F. (2021). TaxonTableTools—A comprehensive, platform-independent graphical user interface software to explore and visualise DNA metabarcoding data. Molecular Ecology Resources. https://doi.org/10.1111/1755-0998.13358

McKnight, D. T., Huerlimann, R., Bower, D. S., Schwarzkopf, L., Alford, R. A., & Zenger, K. R. (2019). microDecon: A highly accurate read-subtraction tool for the post-sequencing removal of contamination in metabarcoding studies. Environmental DNA. https://doi.org/10.1002/edn3.11

# Install package and load libraries
```{r}
# library(devtools)
# devtools::install_github("donaldtmcknight/microDecon")
library(microDecon)
library(tibble)
library(tidyverse)
library(dplyr)
library(readxl)
```

# Prepare OTU tables for microDecon format
We converted our manually curated tables from LULU into the format requested by microDecon (1-3 below). Default options were applied.

A properly formatted OTU table for microDecon should have:
1. First column (OTU_ID) → Unique OTU identifiers.
2. Next columns (Blank samples) → Negative controls (samples with expected contamination).
3. Following columns (Real samples) → Actual biological/metabarcoding samples.
4. Final column (Taxa, optional) → Taxonomic assignment (e.g., Kingdom, Phylum, etc.).

## Load taxonomy tables from created from TaxonTableTools2
```{r}

# load OTU tables
tele02_raw <- read_excel("tele02_taxon_table_microdecon.xlsx", sheet = 1)
vert01_raw <- read_excel("vert01_taxon_table_microdecon.xlsx", sheet = 1)

## collapse tele02 to family + genus + species level
tele02_species <- tele02_raw %>%
  select(Family, Species, starts_with("SRR")) %>%
  group_by(Family, Species) %>%
  summarise(across(starts_with("SRR"), ~ sum(as.numeric(.), na.rm = TRUE)),
            .groups = "drop") %>%
  mutate(OTU_ID = paste(Family, Species, sep = "_"))  # make a combined ID if needed

## collapse vert01 to family + genus + species level
vert01_species <- vert01_raw %>%
  select(Family, Species, starts_with("SRR")) %>%
  group_by(Family, Species) %>%
  summarise(across(starts_with("SRR"), ~ sum(as.numeric(.), na.rm = TRUE)),
            .groups = "drop") %>%
  mutate(OTU_ID = paste(Family, Species, sep = "_"))

# check
nrow(tele02_raw)      # original ASVs
nrow(tele02_species)  # collapsed species
nrow(vert01_raw)
nrow(vert01_species)

str(tele02_species)
str(vert01_species)
head(tele02_species)
head(vert01_species)
```


# Run microDecon for Tele02 River Subsets

```{r}
# define sample information for all tele02 rivers
tele02_river_samples <- list(
  ARGENTINA = list(
    blank = c("SRR31057121-ARGENTINA-neg-Tele02_R1",
              "SRR31057075-NA-PCR_neg-Tele02_R1"),
    real  = c("SRR31057115-ARGENTINA-r1-Tele02_R1",
              "SRR31057116-ARGENTINA-r2-Tele02_R1",
              "SRR31057117-ARGENTINA-r3-Tele02_R1",
              "SRR31057118-ARGENTINA-r4-Tele02_R1",
              "SRR31057119-ARGENTINA-r5-Tele02_R1",
              "SRR31057120-ARGENTINA-r6-Tele02_R1")
  ),
  BEVERA = list(
    blank = c("SRR31057090-BEVERA-neg-Tele02_R1",
              "SRR31057075-NA-PCR_neg-Tele02_R1"),
    real  = c("SRR31057084-BEVERA-r1-Tele02_R1",
              "SRR31057085-BEVERA-r2-Tele02_R1",
              "SRR31057086-BEVERA-r3-Tele02_R1",
              "SRR31057087-BEVERA-r4-Tele02_R1",
              "SRR31057088-BEVERA-r5-Tele02_R1",
              "SRR31057089-BEVERA-r6-Tele02_R1")
  ),
  CARPASINA = list(
    blank = c("SRR31057098-CARPASINA-neg-Tele02_R1",
              "SRR31057075-NA-PCR_neg-Tele02_R1"),
    real  = c("SRR31057091-CARPASINA-r1-Tele02_R1",
              "SRR31057093-CARPASINA-r2-Tele02_R1",
              "SRR31057094-CARPASINA-r3-Tele02_R1",
              "SRR31057095-CARPASINA-r4-Tele02_R1",
              "SRR31057096-CARPASINA-r5-Tele02_R1",
              "SRR31057097-CARPASINA-r6-Tele02_R1")
  ),
  NERVIA = list(
    blank = c("SRR31057083-NERVIA-neg-Tele02_R1",
              "SRR31057075-NA-PCR_neg-Tele02_R1"),
    real  = c("SRR31057076-NERVIA-r1-Tele02_R1",
              "SRR31057077-NERVIA-r2-Tele02_R1",
              "SRR31057078-NERVIA-r3-Tele02_R1",
              "SRR31057079-NERVIA-r4-Tele02_R1",
              "SRR31057080-NERVIA-r5-Tele02_R1",
              "SRR31057082-NERVIA-r6-Tele02_R1")
  ),
  ROIA = list(
    blank = c("SRR31057113-ROIA-neg-Tele02_R1",
              "SRR31057075-NA-PCR_neg-Tele02_R1"),
    real  = c("SRR31057107-ROIA-r1-Tele02_R1",
              "SRR31057108-ROIA-r2-Tele02_R1",
              "SRR31057109-ROIA-r3-Tele02_R1",
              "SRR31057110-ROIA-r4-Tele02_R1",
              "SRR31057111-ROIA-r5-Tele02_R1",
              "SRR31057112-ROIA-r6-Tele02_R1")
  ),
  TANARO = list(
    blank = c("SRR31057106-TANARO-neg-Tele02_R1",
              "SRR31057075-NA-PCR_neg-Tele02_R1"),
    real  = c("SRR31057099-TANARO-r1-Tele02_R1",
              "SRR31057100-TANARO-r2-Tele02_R1",
              "SRR31057101-TANARO-r3-Tele02_R1",
              "SRR31057102-TANARO-r4-Tele02_R1",
              "SRR31057104-TANARO-r5-Tele02_R1",
              "SRR31057105-TANARO-r6-Tele02_R1")
  )
)

# function to check data quality and run microDecon
process_river_microdecon <- function(data, river_name, blank_samples, real_samples, verbose = TRUE) {
  
  if (verbose) cat("\n=== Processing", river_name, "===\n")
  
  # subset
  river_data <- data %>%
    select(OTU_ID, all_of(blank_samples), all_of(real_samples))
  
  otu_ids <- river_data$OTU_ID
  counts <- as.data.frame(river_data[,-1])
  
  # force numeric + replace NA with 0
  counts <- counts %>% mutate(across(everything(), ~ suppressWarnings(as.numeric(.))))
  counts[is.na(counts)] <- 0
  
  # drop OTUs with zero counts across all samples/blanks
  keep_rows <- rowSums(counts) > 0
  counts <- counts[keep_rows, , drop = FALSE]
  otu_ids <- otu_ids[keep_rows]
  
  # check blanks individually
  blank_totals <- colSums(counts[, blank_samples, drop = FALSE])
  blank_has_zero <- any(blank_totals == 0)
  
  if (blank_has_zero) {
    if (verbose) {
      cat("WARNING:", sum(blank_totals == 0), "blank(s) are all zeros → skipping microDecon.\n")
    }
    result <- list(
      decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE])
    )
  } else {
    # check overlap between blanks and real samples
    overlap <- rowSums(counts[, blank_samples, drop = FALSE]) > 0 &
               rowSums(counts[, real_samples, drop = FALSE]) > 0
    
    if (!any(overlap)) {
      if (verbose) cat("WARNING: no OTU overlap between blanks and samples → skipping microDecon.\n")
      result <- list(
        decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE])
      )
    } else {
      if (verbose) cat("Running microDecon...\n")
      
      # build clean input
      decon_input <- cbind(OTU_ID = otu_ids, counts)
      rownames(decon_input) <- NULL   # drop rownames just in case
      
      # if any NA remains, stop
      if (anyNA(decon_input)) {
        if (verbose) cat("WARNING: NAs found in input → skipping microDecon.\n")
        result <- list(
          decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE])
        )
      } else {
        # call microDecon
        result <- tryCatch({
          decon(
            data = decon_input,
            numb.blanks = length(blank_samples),
            numb.ind = length(real_samples),
            taxa = FALSE
          )
        }, error = function(e) {
          if (verbose) cat("ERROR in microDecon:", conditionMessage(e), "→ skipping.\n")
          list(decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE]))
        })
      }
    }
  }
  
  # final NA→0 safeguard
  result$decon.table <- as.data.frame(result$decon.table)
  result$decon.table[is.na(result$decon.table)] <- 0
  
  if (verbose) {
    cat("Output dimensions:", nrow(result$decon.table), "x", ncol(result$decon.table), "\n")
  }
  
  return(result)
}

# process all rivers
tele02_cleaned_results <- list()

for (river in names(tele02_river_samples)) {
  tele02_cleaned_results[[river]] <- process_river_microdecon(
    data = tele02_species,
    river_name = river,
    blank_samples = tele02_river_samples[[river]]$blank,
    real_samples = tele02_river_samples[[river]]$real,
    verbose = TRUE
  )
}

# access individual results
tele02_argentina_cleaned <- tele02_cleaned_results$ARGENTINA
tele02_bevera_cleaned <- tele02_cleaned_results$BEVERA
tele02_carpasina_cleaned <- tele02_cleaned_results$CARPASINA
tele02_nervia_cleaned <- tele02_cleaned_results$NERVIA
tele02_roia_cleaned <- tele02_cleaned_results$ROIA
tele02_tanaro_cleaned <- tele02_cleaned_results$TANARO

# summary of all results
cat("\n=== TELE02 SUMMARY ===\n")
for (river in names(tele02_cleaned_results)) {
  result <- tele02_cleaned_results[[river]]
  cat(sprintf("%s: %d OTUs x %d samples\n", 
              river, 
              nrow(result$decon.table), 
              ncol(result$decon.table) - 1))  # -1 for OTU_ID column
}
```


# Run microDecon for Vert01 River Subsets

```{r}
# define sample information for all vert01 rivers
vert01_river_samples <- list(
  ARGENTINA = list(
    blank = c("SRR31057159-ARGENTINA-neg-Vert01_R1",
              "SRR31057123-NA-PCR_neg-Vert01_R1"),
    real  = c("SRR31057103-ARGENTINA-r1-Vert01_R1",
              "SRR31057114-ARGENTINA-r2-Vert01_R1",
              "SRR31057125-ARGENTINA-r3-Vert01_R1",
              "SRR31057136-ARGENTINA-r4-Vert01_R1",
              "SRR31057147-ARGENTINA-r5-Vert01_R1",
              "SRR31057158-ARGENTINA-r6-Vert01_R1")
  ),
  BEVERA = list(
    blank = c("SRR31057139-BEVERA-neg-Vert01_R1",
              "SRR31057123-NA-PCR_neg-Vert01_R1"),
    real  = c("SRR31057132-BEVERA-r1-Vert01_R1",
              "SRR31057133-BEVERA-r2-Vert01_R1",
              "SRR31057134-BEVERA-r3-Vert01_R1",
              "SRR31057135-BEVERA-r4-Vert01_R1",
              "SRR31057137-BEVERA-r5-Vert01_R1",
              "SRR31057138-BEVERA-r6-Vert01_R1")
  ),
  CARPASINA = list(
    blank = c("SRR31057146-CARPASINA-neg-Vert01_R1",
              "SRR31057123-NA-PCR_neg-Vert01_R1"),
    real  = c("SRR31057140-CARPASINA-r1-Vert01_R1",
              "SRR31057141-CARPASINA-r2-Vert01_R1",
              "SRR31057142-CARPASINA-r3-Vert01_R1",
              "SRR31057143-CARPASINA-r4-Vert01_R1",
              "SRR31057144-CARPASINA-r5-Vert01_R1",
              "SRR31057145-CARPASINA-r6-Vert01_R1")
  ),
  NERVIA = list(
    blank = c("SRR31057131-NERVIA-neg-Vert01_R1",
              "SRR31057123-NA-PCR_neg-Vert01_R1"),
    real  = c("SRR31057124-NERVIA-r1-Vert01_R1",
              "SRR31057126-NERVIA-r2-Vert01_R1",
              "SRR31057127-NERVIA-r3-Vert01_R1",
              "SRR31057128-NERVIA-r4-Vert01_R1",
              "SRR31057129-NERVIA-r5-Vert01_R1",
              "SRR31057130-NERVIA-r6-Vert01_R1")
  ),
  ROIA = list(
    blank = c("SRR31057092-ROIA-neg-Vert01_R1",
              "SRR31057123-NA-PCR_neg-Vert01_R1"),
    real  = c("SRR31057155-ROIA-r1-Vert01_R1",
              "SRR31057156-ROIA-r2-Vert01_R1",
              "SRR31057157-ROIA-r3-Vert01_R1",
              "SRR31057072-ROIA-r4-Vert01_R1",
              "SRR31057073-ROIA-r5-Vert01_R1",
              "SRR31057081-ROIA-r6-Vert01_R1")
  ),
  TANARO = list(
    blank = c("SRR31057154-TANARO-neg-Vert01_R1",
              "SRR31057123-NA-PCR_neg-Vert01_R1"),
    real  = c("SRR31057148-TANARO-r1-Vert01_R1",
              "SRR31057149-TANARO-r2-Vert01_R1",
              "SRR31057150-TANARO-r3-Vert01_R1",
              "SRR31057151-TANARO-r4-Vert01_R1",
              "SRR31057152-TANARO-r5-Vert01_R1",
              "SRR31057153-TANARO-r6-Vert01_R1")
  )
)

# function to check data quality and run microDecon
process_river_microdecon <- function(data, river_name, blank_samples, real_samples, verbose = TRUE) {
  
  if (verbose) cat("\n=== Processing", river_name, "- Vert01 ===\n")
  
  # subset
  river_data <- data %>%
    select(OTU_ID, all_of(blank_samples), all_of(real_samples))
  
  otu_ids <- river_data$OTU_ID
  counts <- as.data.frame(river_data[,-1])
  
  # force numeric and replace NA with 0
  counts <- counts %>% dplyr::mutate(across(everything(), ~ suppressWarnings(as.numeric(.))))
  counts[is.na(counts)] <- 0
  
  # drop OTUs that are all-zero across blanks+samples
  keep_rows <- rowSums(counts) > 0
  counts <- counts[keep_rows, , drop = FALSE]
  otu_ids <- otu_ids[keep_rows]
  
  # check blanks individually
  blank_totals <- colSums(counts[, blank_samples, drop = FALSE])
  blank_has_zero <- any(blank_totals == 0)
  
  if (blank_has_zero) {
    if (verbose) cat("WARNING:", sum(blank_totals == 0), "blank(s) are all zeros → skipping microDecon.\n")
    result <- list(
      decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE])
    )
  } else {
    # check overlap between blanks and real samples
    overlap <- rowSums(counts[, blank_samples, drop = FALSE]) > 0 &
               rowSums(counts[, real_samples, drop = FALSE]) > 0
    
    if (!any(overlap)) {
      if (verbose) cat("WARNING: no OTU overlap between blanks and samples → skipping microDecon.\n")
      result <- list(
        decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE])
      )
    } else {
      if (verbose) cat("Running microDecon...\n")
      
      decon_input <- cbind(OTU_ID = otu_ids, counts)
      rownames(decon_input) <- NULL
      
      if (anyNA(decon_input)) {
        if (verbose) cat("WARNING: NAs found in input → skipping microDecon.\n")
        result <- list(
          decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE])
        )
      } else {
        result <- tryCatch({
          decon(
            data = decon_input,
            numb.blanks = length(blank_samples),
            numb.ind = length(real_samples),
            taxa = FALSE
          )
        }, error = function(e) {
          if (verbose) cat("ERROR in microDecon:", conditionMessage(e), "→ skipping.\n")
          list(decon.table = cbind(OTU_ID = otu_ids, counts[, real_samples, drop = FALSE]))
        })
      }
    }
  }
  
  if (verbose) {
    cat("Output dimensions:", nrow(result$decon.table), "x", ncol(result$decon.table), "\n")
  }
  
  return(result)
}

# process all vert01 rivers
vert01_cleaned_results <- list()

for (river in names(vert01_river_samples)) {
  vert01_cleaned_results[[river]] <- process_river_microdecon(
    data = vert01_species,
    river_name = river,
    blank_samples = vert01_river_samples[[river]]$blank,
    real_samples = vert01_river_samples[[river]]$real,
    verbose = TRUE
  )
}

# access individual results
vert01_argentina_cleaned <- vert01_cleaned_results$ARGENTINA
vert01_bevera_cleaned    <- vert01_cleaned_results$BEVERA
vert01_carpasina_cleaned <- vert01_cleaned_results$CARPASINA
vert01_nervia_cleaned    <- vert01_cleaned_results$NERVIA
vert01_roia_cleaned      <- vert01_cleaned_results$ROIA
vert01_tanaro_cleaned    <- vert01_cleaned_results$TANARO

# summary of all vert01 results
cat("\n=== VERT01 SUMMARY ===\n")
for (river in names(vert01_cleaned_results)) {
  result <- vert01_cleaned_results[[river]]
  cat(sprintf("%s: %d OTUs x %d samples\n",
              river,
              nrow(result$decon.table),
              ncol(result$decon.table) - 1))  # -1 for OTU_ID column
}
```





# Final Taxon Lists by River (individual samples) and Marker
```{r}
# function to save cleaned results for a marker
save_marker_results <- function(results_list, marker_name) {
  for (river in names(results_list)) {
    filename <- paste0(tolower(marker_name), "_", tolower(river), "_cleaned.csv")
    write.csv(results_list[[river]]$decon.table, filename, row.names = FALSE)
    cat("Saved:", filename, "\n")
  }
}

# save all results
save_marker_results(tele02_cleaned_results, "Tele02")
save_marker_results(vert01_cleaned_results, "Vert01")
```



# Final Taxon Lists by Marker
```{r}
# function to process marker results into summed output
process_marker_output <- function(results_list, marker_name) {
  
  cat("Processing", marker_name, "results...\n")
  
  # process all rivers at once using map and reduce
  river_data <- map(names(results_list), function(river) {
    df <- results_list[[river]]$decon.table
    
    # sum reads across all sample columns (excluding OTU_ID)
    df_summed <- df %>%
      mutate(!!tolower(river) := rowSums(select(., -OTU_ID))) %>%
      select(OTU_ID, !!tolower(river))
    
    return(df_summed)
  })
  
  # combine all rivers with full joins
  output <- reduce(river_data, full_join, by = "OTU_ID")
  
  # replace NAs with 0s
  output[is.na(output)] <- 0
  
  cat("Completed", marker_name, "with", nrow(output), "OTUs across", 
      ncol(output)-1, "rivers\n")
  
  return(output)
}

# process both markers
tele02_microdecon_output <- process_marker_output(tele02_cleaned_results, "Tele02")
vert01_microdecon_output <- process_marker_output(vert01_cleaned_results, "Vert01")

# check
head(tele02_microdecon_output)
head(vert01_microdecon_output)

# save files
write.csv(tele02_microdecon_output, "tele02_microdecon_output.csv", row.names = FALSE)
write.csv(vert01_microdecon_output, "vert01_microdecon_output.csv", row.names = FALSE)

cat("Files saved successfully!\n")
```




